# Clean Code

## 有意义的命名

1. 名副其实：直接体现变量/函数/类/对象作用

2. 避免误导：
   > * 错误线索，如：带List的命名，实际并不是List类型
   > * 提防使用区别较小的名称，防止编辑器自动填充问题

3. 有意义的区分：
   > * 相似的函数名容易混淆作用，如：getUserInfo, getUserData
   > * 需要明确约定，info与data的区别

4. 使用读得出来的名称：避免自造词

5. 使用可搜索的名称：名称长短应与其作用域大小对应

6. 类/函数名：
   > * 类名应为名词或名词短语，而不是动词，首字母大写
   > * 函数名应为动词或动词短语，驼峰命名法

7. 每个概念对应一个词：
   > * 约定某个概念对应确定的词
   > * 比如抓取，约定用get而不是fetch或retrieve

## 函数

1. 简明：控制一定长度范围

2. 只做一件事：能否再拆分出至少一个函数

3. 每个函数一个抽象层级：
   > * 所有语句在同一抽象层级上
   > * 自顶向下阅读代码，每个函数后面跟着下一层级的函数

4. 使用描述性的名称：
   > * 别害怕长名称
   > * 别害怕花时间取名字
   > * 保持一致的命名方式

5. 函数参数：
   > * 尽量避免三个或以上的参数
   > * 某些二元函数，expected在前，actual在后
   > * 三个参数或以上，可将其变成对象，再传入
   > * 函数名字来提示参数的顺序及其意图

6. 避免副作用

7. 分隔指令与询问：将可能混淆的执行语句与条件判断分隔开来

8. 使用异常替代返回错误码：错误处理就是一件事，应为一个独立的函数

## 注释

1. 弥补用代码来表达意图时的失败

2. 不能美化糟糕的代码

3. 好注释：
   > * 法律信息
   > * 提供信息的注释
   > * 对意图的解释
   > * 警示
   > * TODO注释：作者认为应该做，但未做的工作
   > * 公共API的doc

4. 坏注释：糟糕代码的借口，自言自语
   > * 循规式注释，并不是所有api都需要doc
   > * 日志式注释，记录每次修改的日志（窃以为即便有gitlab等版本控制系统的记录，也有其存在的意义）
   > * 位置标记
   > * 归属与署名
   > * 注释掉的代码：别人不敢删掉

## 代码风格

1. 垂直格式：
   > * 文件顶部为高层次的概念和算法，细节依次向下展开
   > * 每个概念间应留出一行间距，紧密相关的代码相互靠近
   > * 变量声明尽可能靠近使用位置，本地变量应在函数顶部出现，实体变量应在类的顶部声明
   > * 相关函数，若某函数引用了另一函数，应将其放一起，被调用者放于下方（视程序语言而变）

## 单元测试

1. 每个测试一个断言

2. 每个测试一个概念

3. F.I.R.S.T:
   > * 快速：短时间内完成
   > * 独立：应相互独立，前一个测试不应作为后一个的前提条件
   > * 可重复
   > * 自足验证：测试结果有布尔值输出，而不是查看过程日志
   > * 及时


## 并发编程

### 并发防御原则

1. 单一权责原则：方法/类/模块应该有且只有一条加以修改的理由
   > 分离并发相关代码与其他代码

2. 限制数据作用域：谨记数据封装，严格限制可能共享的数据的访问

3. 使用数据复本：考虑额外对象的成本

4. 线程尽可能相互独立：尝试将数据分解到可独立的线程

### 执行模型

1. 基本概念：
   > * 限定资源：并发环境中有着固定尺寸或数量的资源
   > * 互斥：每一时刻仅有一个线程能访问的共享资源
   > * 线程饥饿：一个/一组线程在很久时间/永久被禁止。 如：总是让执行快的线程先运行，若快的线程没完没了，则执行时间长的线程就会‘饥饿’
   > * 死锁：两个/多个线程相互等待执行结束。每个线程都拥有其他线程需要的资源，得不到需要的资源就无法终止
   > * 活锁：执行次序一致的线程，每个想要起步，但其他线程已经“在路上”。由于竞步的原因，线程会持续尝试起步，但在很长时间内无法如愿，甚至用于无法启动。

2. 生产者-消费者模型：一个/多个生产者创建工作，置于队列中，一个/多个消费者取之并执行

3. 作者-读者模型：作者不定时更新共享资源，读者读取并执行相关任务

